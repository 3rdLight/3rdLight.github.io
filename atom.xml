<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mute</title>
  
  <subtitle>个人技术博客</subtitle>
  <link href="http://3rdlight.github.io/atom.xml" rel="self"/>
  
  <link href="http://3rdlight.github.io/"/>
  <updated>2022-10-15T10:16:42.209Z</updated>
  <id>http://3rdlight.github.io/</id>
  
  <author>
    <name>Dust2朱师傅</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>README</title>
    <link href="http://3rdlight.github.io/2022/10/15/README/"/>
    <id>http://3rdlight.github.io/2022/10/15/README/</id>
    <published>2022-10-15T09:36:13.000Z</published>
    <updated>2022-10-15T10:16:42.209Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>补码一位乘法</title>
    <link href="http://3rdlight.github.io/2022/10/15/%E8%A1%A5%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98%E6%B3%95/"/>
    <id>http://3rdlight.github.io/2022/10/15/%E8%A1%A5%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98%E6%B3%95/</id>
    <published>2022-10-15T09:26:06.000Z</published>
    <updated>2022-10-15T09:26:06.116Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>原码一位乘法</title>
    <link href="http://3rdlight.github.io/2022/10/15/%E5%8E%9F%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98%E6%B3%95/"/>
    <id>http://3rdlight.github.io/2022/10/15/%E5%8E%9F%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98%E6%B3%95/</id>
    <published>2022-10-15T09:25:57.000Z</published>
    <updated>2022-10-15T09:25:57.270Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>海明校验</title>
    <link href="http://3rdlight.github.io/2022/10/05/%E6%B5%B7%E6%98%8E%E6%A0%A1%E9%AA%8C/"/>
    <id>http://3rdlight.github.io/2022/10/05/%E6%B5%B7%E6%98%8E%E6%A0%A1%E9%AA%8C/</id>
    <published>2022-10-05T05:11:15.000Z</published>
    <updated>2022-10-15T08:56:29.641Z</updated>
    
    <content type="html"><![CDATA[<p>海明码是一种多重奇偶检错系统，用于检错和纠错。</p><p><strong>以下内容都以 例题：“设8位有效信息为01101110，写出它的的海明校验码” 为例。</strong>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               </p><span id="more"></span><h4 id="1-校验位的位数"><a href="#1-校验位的位数" class="headerlink" title="1.校验位的位数"></a>1.校验位的位数</h4><p>设海明校验码H<sub>n</sub>…H<sub>2</sub>H<sub>1</sub>共有n位，原始有效信息D<sub>k</sub>…D<sub>2</sub>D<sub>1</sub>共k位，称为(n,k)码，校验位P<sub>r</sub>…P<sub>2</sub>P<sub>1</sub>，包含r个偶校验组，n &#x3D; k + r 。</p><p>为了能指出n位海明码中的所有一位错，<strong>每个原始数据位至少位于两个以上的校验组</strong>，这样才能通过检错码G<sub>r</sub>…G<sub>2</sub>G<sub>1</sub>对照检错。</p><p>n，k，r应满足：<strong>n &#x3D; k + r &lt;&#x3D; 2 <sup>r</sup> - 1</strong> </p><p><strong>表为 k 与 r 不同组合的关系</strong></p><table><thead><tr><th align="center">k</th><th align="center">1</th><th align="center">2 ~ 4</th><th align="center">5 ~ 11</th><th align="center">12 ~ 26</th><th align="center">27 ~ 57</th></tr></thead><tbody><tr><td align="center">r</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">6</td></tr></tbody></table><p>例题原始信息共8位，k &#x3D; 8， r &#x3D; 4 ，n &#x3D; 12 ， 称为（12 ，8）码。</p><h4 id="2-编码规则"><a href="#2-编码规则" class="headerlink" title="2.编码规则"></a>2.编码规则</h4><h5 id="1-校验位在海明码中的映射"><a href="#1-校验位在海明码中的映射" class="headerlink" title="1.校验位在海明码中的映射"></a>1.校验位在海明码中的映射</h5><p><strong>校验位P<sub>1-4</sub>对应在海明码H<sub>1-12</sub>中位置的关系为 2<sup> n - 1 </sup></strong> （n为P中的1~4），如P<sub>1</sub>  对应H<sub>(2<sup>1-1</sup>)</sub> 就是H<sub>1</sub>，P<sub>2</sub>  对应H<sub>(2<sup>2-1</sup>)</sub> 就是H<sub>2</sub> ，P<sub>3</sub>  对应H<sub>(2<sup>3-1</sup>)</sub> 就是H<sub>4</sub>，P<sub>4</sub>  对应H<sub>(2<sup>4-1</sup>)</sub> 就是H<sub>8</sub> 。（详见下表）</p><p>所有校验位都应该存放在 <strong>幂次方</strong> 位上，校验位位置映射完成后，将原始数据位D<sub>1</sub>D<sub>2</sub>…D<sub>k</sub>依次填入即可。</p><p>所以海明码H<sub>1</sub>H<sub>2</sub>…H<sub>12</sub>就是  <strong>P<sub>1</sub>P<sub>2</sub>D<sub>1</sub>P<sub>3</sub>D<sub>2</sub>D<sub>3</sub>D<sub>4</sub>P<sub>4</sub> D<sub>5</sub>D<sub>6</sub>D<sub>7</sub>D<sub>8</sub></strong> </p><h6 id="校验位的逻辑表达式"><a href="#校验位的逻辑表达式" class="headerlink" title="校验位的逻辑表达式"></a>校验位的逻辑表达式</h6><p>注：” ⊕ “ 符号为异或，相同取0，不同取1 。</p><p>P<sub>1</sub> &#x3D; D<sub>1</sub> ⊕ D<sub>2</sub> ⊕ D<sub>4</sub> ⊕ D<sub>5</sub> ⊕ D<sub>7</sub>  &#x3D; 1（ D<sub>1</sub>、…、D<sub>7</sub>为下表中P<sub>1</sub>所对应的G<sub>1</sub>校验组中标记过的原始数据位，以下同理）</p><p>P<sub>2</sub> &#x3D; D<sub>1</sub> ⊕ D<sub>3</sub> ⊕ D<sub>4</sub> ⊕ D<sub>6</sub> ⊕ D<sub>7</sub>  &#x3D; 1</p><p>P<sub>3</sub> &#x3D; D<sub>2</sub> ⊕ D<sub>3</sub> ⊕ D<sub>4</sub> ⊕ D<sub>8</sub>  &#x3D;  0</p><p>P<sub>4</sub> &#x3D; D<sub>5</sub> ⊕ D<sub>6</sub> ⊕ D<sub>7</sub> ⊕ D<sub>8</sub>   &#x3D; 1</p><p>代入数据，所以原始数据01101110的海明码为 110011011110</p><h5 id="2-校验组（G1-4）"><a href="#2-校验组（G1-4）" class="headerlink" title="2.校验组（G1 ~ 4）"></a>2.校验组（G<sub>1 ~ 4</sub>）</h5><p>在G<sub>1</sub>行中共有6个 “ √ ” 标记，其对应的海明码分别为H<sub>1</sub>、H<sub>3</sub>、H<sub>5</sub>、H<sub>7</sub>、H<sub>9</sub>、H<sub>11</sub> ，它们所对应的检错码均为 “ ###1 ”（第四位数为1），代表H<sub>1</sub>、H<sub>3</sub>、H<sub>5</sub>、H<sub>7</sub>、H<sub>9</sub>、H<sub>11</sub> 都参与了校验组G<sub>1</sub>的校验。 （详见下表）</p><p>在G<sub>3</sub>行中共有5个 “ √ ” 标记，其对应的海明码分别为H<sub>4</sub>、H<sub>5</sub>、H<sub>6</sub>、H<sub>7</sub>、H<sub>12</sub> ，它们所对应的检错码均为 “ #1## ”（第二位数为1），代表H<sub>4</sub>、H<sub>5</sub>、H<sub>6</sub>、H<sub>7</sub>、H<sub>12</sub> 都参与了校验组G<sub>3</sub>的校验。</p><p>校验组G<sub>2</sub>、G<sub>4</sub> 同理。</p><p><strong>校验组分组为：</strong></p><p>G<sub>1 </sub> ：P<sub>1</sub>  D<sub>1</sub>  D<sub>2</sub>  D<sub>4</sub>  D<sub>5</sub>  D<sub>7</sub> </p><p>G<sub>2</sub>  ：P<sub>2</sub>  D<sub>1</sub>  D<sub>3</sub>  D<sub>4</sub>  D<sub>6</sub>  D<sub>7</sub>  </p><p>G<sub>3</sub>  ：P<sub>3</sub>  D<sub>2</sub>  D<sub>3</sub>  D<sub>4</sub>  D<sub>8</sub>  </p><p>G<sub>4</sub>  ：P<sub>4</sub>  D<sub>5</sub>  D<sub>6</sub>  D<sub>7</sub>  D<sub>8</sub>  </p><h6 id="校验组的逻辑表达式："><a href="#校验组的逻辑表达式：" class="headerlink" title="校验组的逻辑表达式："></a>校验组的逻辑表达式：</h6><p>G<sub>1</sub> &#x3D; P<sub>1</sub> ⊕ D<sub>1</sub> ⊕ D<sub>2</sub> ⊕ D<sub>4</sub> ⊕ D<sub>5</sub> ⊕ D<sub>7</sub>  &#x3D; 0</p><p>G<sub>2</sub> &#x3D; P<sub>2</sub> ⊕ D<sub>1</sub> ⊕ D<sub>3</sub> ⊕ D<sub>4</sub> ⊕ D<sub>6</sub> ⊕ D<sub>7</sub>  &#x3D; 0</p><p>G<sub>3</sub> &#x3D; P<sub>3</sub> ⊕ D<sub>2</sub> ⊕ D<sub>3</sub> ⊕ D<sub>4</sub> ⊕ D<sub>8</sub>  &#x3D;  0</p><p>G<sub>4</sub> &#x3D; P<sub>4</sub> ⊕ D<sub>5</sub> ⊕ D<sub>6</sub> ⊕ D<sub>7</sub> ⊕ D<sub>8</sub>   &#x3D; 0</p><p><strong>表为例题（12，8）码对应的编码规则</strong></p><table><thead><tr><th align="center">海明码</th><th>H<sub>1</sub></th><th>H<sub>2</sub></th><th>H<sub>3</sub></th><th>H<sub>4</sub></th><th>H<sub>5</sub></th><th>H<sub>6</sub></th><th>H<sub>7</sub></th><th>H<sub>8</sub></th><th>H<sub>9</sub></th><th>H<sub>10</sub></th><th>H<sub>11</sub></th><th>H<sub>12</sub></th></tr></thead><tbody><tr><td align="center">映射关系</td><td><strong>P<sub>1</sub></strong></td><td><strong>P<sub>2</sub></strong></td><td>D<sub>1</sub></td><td><strong>P<sub>3</sub></strong></td><td>D<sub>2</sub></td><td>D<sub>3</sub></td><td>D<sub>4</sub></td><td><strong>P<sub>4</sub></strong></td><td>D<sub>5</sub></td><td>D<sub>6</sub></td><td>D<sub>7</sub></td><td>D<sub>8</sub></td></tr><tr><td align="center">检错码</td><td>0001</td><td>0010</td><td>0011</td><td>0100</td><td>0101</td><td>0110</td><td>0111</td><td>1000</td><td>1001</td><td>1010</td><td>1011</td><td>1100</td></tr><tr><td align="center">G<sub>1</sub></td><td>√</td><td></td><td>√</td><td></td><td>√</td><td></td><td>√</td><td></td><td>√</td><td></td><td>√</td><td></td></tr><tr><td align="center">G<sub>2</sub></td><td></td><td>√</td><td>√</td><td></td><td></td><td>√</td><td>√</td><td></td><td></td><td>√</td><td>√</td><td></td></tr><tr><td align="center">G<sub>3</sub></td><td></td><td></td><td></td><td>√</td><td>√</td><td>√</td><td>√</td><td></td><td></td><td></td><td></td><td>√</td></tr><tr><td align="center">G<sub>4</sub></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><h4 id="3-检错与纠错"><a href="#3-检错与纠错" class="headerlink" title="3.检错与纠错"></a>3.检错与纠错</h4><p>在接收端收到海明码后，按上述分组检验每组的正确性,每组异或为0则该组没出错，否则该组出错。</p><p>若G<sub>4</sub>G<sub>3</sub>G<sub>2</sub>G<sub>1</sub> &#x3D; 0000 ，则<strong>大概率</strong>没有出错。</p><p>若G<sub>4</sub>G<sub>3</sub>G<sub>2</sub>G<sub>1</sub> &#x3D; 1010 ，则G<sub>4</sub>和G<sub>2</sub>出错，只有D<sub>6</sub>和D<sub>7</sub>都参与了检验组G<sub>4</sub>和G<sub>2</sub>的校验，但D<sub>7</sub>还参与了检验组G<sub>1</sub>的校验，如果D<sub>7</sub>出错，检验组G<sub>1</sub>也应该出错，所以出错的位置是D<sub>6</sub> ；也可理解为1010的十进制是10，则海明码H<sub>10</sub>（数据D<sub>6</sub>）出错，将H<sub>10</sub>取反即可。</p><p>注：若十进制对应的位置是校验位P出错，不需要纠正，因为我们只需要确保数据不出错就可以。</p><p>若例题中接收方收到的有效信息变为01101111，则G<sub>4</sub>G<sub>3</sub>G<sub>2</sub>G<sub>1</sub> &#x3D; 1100 ， 海明码H<sub>12</sub>（数据D<sub>8</sub>）出错，将H<sub>12</sub>取反为0即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;海明码是一种多重奇偶检错系统，用于检错和纠错。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下内容都以 例题：“设8位有效信息为01101110，写出它的的海明校验码” 为例。&lt;/strong&gt;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               &lt;/p&gt;</summary>
    
    
    
    <category term="计算机组成原理" scheme="http://3rdlight.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="海明校验" scheme="http://3rdlight.github.io/tags/%E6%B5%B7%E6%98%8E%E6%A0%A1%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>常见排序算法汇总</title>
    <link href="http://3rdlight.github.io/2022/04/12/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/"/>
    <id>http://3rdlight.github.io/2022/04/12/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/</id>
    <published>2022-04-11T19:44:47.000Z</published>
    <updated>2022-04-17T00:27:36.152Z</updated>
    
    <content type="html"><![CDATA[<p>大多数时候我们可以选择直接调用库函数来对序列进行排序，这里主要总结三种常见的复杂度较低的排序。</p><span id="more"></span><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><p>在待排序的数列中，我们首先要找一个数字作为基准数。我们一般选择第 1 个数字作为基准数。接下来我们需要把这个待排序的数列中小于基准数的元素移动到待排序的数列的左边，把大于基准数的元素移动到待排序的数列的右边。这时，基于准基数的左右两个分区的元素就相对有序了；接着把两个分区的元素分别按照上面两种方法继续对每个分区找出基准数，然后移动，直到各个分区只有一个数时为止。</p><p>这是典型的分治思想，即分治法。</p><p>快速排序是<strong>【不稳定排序】</strong></p><h5 id="时间-x2F-空间复杂度："><a href="#时间-x2F-空间复杂度：" class="headerlink" title="时间&#x2F;空间复杂度："></a>时间&#x2F;空间复杂度：</h5><p>理想情况的时间复杂度是 <code>O(NlogN)</code>，空间复杂度 <code>O(logN)</code>，极端情况下的最坏时间复杂度是 <code>O(N^2)</code>，空间复杂度是 <code>O(N)</code>。</p><p>为了避免出现极端情况，需要引入随机性，将数组随机打乱。</p><h5 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> partition = nums[left]; <span class="comment">//第一个数作为partition</span></span><br><span class="line">        <span class="type">int</span> start = left; <span class="comment">//记录初始位置，当一轮快排结束后，start指向partition位置，用于和最后的left交换</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123; <span class="comment">//约束条件，保证left不会越过right</span></span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] &gt; partition) right--;<span class="comment">//取的左边的数作为partition</span></span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] &lt;= partition) left++; <span class="comment">//所以先遍历右边</span></span><br><span class="line">            <span class="keyword">if</span>(left &lt; right) <span class="built_in">swap</span>(nums[left],nums[right]); <span class="comment">// 交换左右位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[left],nums[start]); <span class="comment">//交换partition和nums[left]值</span></span><br><span class="line">        <span class="keyword">return</span> left; <span class="comment">//此时partition左边的数都小于partition，右边的数都大于partition</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)&#123; </span><br><span class="line">            <span class="type">int</span> partition = <span class="built_in">findPartition</span>(nums,left,right); <span class="comment">//确定partition的位置</span></span><br><span class="line">            <span class="built_in">quickSort</span>(nums,left,partition - <span class="number">1</span>);  <span class="comment">//对partition左边的数进行排序</span></span><br><span class="line">            <span class="built_in">quickSort</span>(nums,partition + <span class="number">1</span>,right); <span class="comment">//对partition右边的数进行排序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        std::<span class="built_in">random_shuffle</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>()); <span class="comment">//随机打乱，防止出现极端情况</span></span><br><span class="line">        <span class="built_in">quickSort</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><h5 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h5><p>将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。反复执行，便能得到一个有序序列。</p><p>堆排序是一种<strong>选择排序</strong>，同样是【<strong>不稳定排序</strong>】</p><h5 id="时间-x2F-空间复杂度：-1"><a href="#时间-x2F-空间复杂度：-1" class="headerlink" title="时间&#x2F;空间复杂度："></a>时间&#x2F;空间复杂度：</h5><p>时间复杂度是 <code>O(NlogN)</code>，空间复杂度 <code>O(logN)</code></p><h5 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造初始堆，将给定无序序列构造成一个大顶堆</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">maxHeap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> heapSize,<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>, right = <span class="number">2</span> * i + <span class="number">2</span>, largest = i;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; heapSize &amp;&amp; nums[left] &gt; nums[largest]) largest = left;</span><br><span class="line">        <span class="keyword">if</span>(right &lt; heapSize &amp;&amp; nums[right] &gt; nums[largest]) largest = right;</span><br><span class="line">        <span class="keyword">if</span>(largest != i)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[largest],nums[i]);</span><br><span class="line">            <span class="built_in">maxHeap</span>(nums,heapSize,largest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造堆</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildHeap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> heapSize)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = heapSize / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="built_in">maxHeap</span>(nums,heapSize,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> heapSize = nums.<span class="built_in">size</span>(); </span><br><span class="line">        <span class="built_in">buildHeap</span>(nums,heapSize);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;=<span class="number">0</span>; i--)&#123; <span class="comment">//将堆顶元素与末尾元素交换，将最大元素沉到数组末端</span></span><br><span class="line">            <span class="built_in">swap</span>(nums[i],nums[<span class="number">0</span>]);<span class="comment">//重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素</span></span><br><span class="line">            heapSize--;<span class="comment">//反复执行，直到整个序列有序</span></span><br><span class="line">            <span class="built_in">maxHeap</span>(nums,heapSize,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><h5 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h5><p>归并排序利用了分治的思想来对序列进行排序。对一个长为 N的待排序的序列，我们将其分解成两个长度为N&#x2F;2的子序列。每次先递归调用函数使两个子序列有序，然后我们再线性合并两个有序的子序列使整个序列有序。</p><p>归并排序是<strong>【稳定排序】</strong> </p><h5 id="时间-x2F-空间复杂度：-2"><a href="#时间-x2F-空间复杂度：-2" class="headerlink" title="时间&#x2F;空间复杂度："></a>时间&#x2F;空间复杂度：</h5><p>时间复杂度是 <code>O(NlogN)</code>，空间复杂度 <code>O(N)</code></p><h5 id="代码实现：-2"><a href="#代码实现：-2" class="headerlink" title="代码实现："></a>代码实现：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">mergeSort</span>(nums, l, mid);</span><br><span class="line">        <span class="built_in">mergeSort</span>(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="type">int</span> i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= nums[j]) &#123;</span><br><span class="line">                tmp[cnt++] = nums[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmp[cnt++] = nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            tmp[cnt++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= r) &#123;</span><br><span class="line">            tmp[cnt++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r - l + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            nums[i + l] = tmp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        tmp.<span class="built_in">resize</span>((<span class="type">int</span>)nums.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">mergeSort</span>(nums, <span class="number">0</span>, (<span class="type">int</span>)nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//冒泡排序</span></span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n-i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt;nums[j<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> temp=nums[j];</span><br><span class="line">                    nums[j]=nums[j<span class="number">-1</span>];</span><br><span class="line">                    nums[j<span class="number">-1</span>]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//选择排序 每次将当前元素替换为后面最小的元素</span></span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> min=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[min]&gt;nums[j])</span><br><span class="line">                    min=j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(min!=i)</span><br><span class="line">                <span class="built_in">swap</span>(nums[i],nums[min]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 假设一个数组，在其内部，数已经按照升序排列，此时有一个新的数a要加入数组，那么数组内大于a的数字需不断地向后腾出位置，直到a找到自己的位置，就可以将a插入该位置，此时原数组仍保持升序排列</span></span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> flag=nums[i];</span><br><span class="line">            <span class="type">int</span> j=i<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span>&amp;&amp;flag&lt;nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                nums[j+<span class="number">1</span>]=nums[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j+<span class="number">1</span>]=flag;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> max=nums[<span class="number">0</span>],min=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;max)</span><br><span class="line">                max=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;min)</span><br><span class="line">                min=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(max-min+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            count[nums[i]-min]++;</span><br><span class="line">        <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;max-min+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(count[i]--)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[k++]=i+min;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> max=<span class="built_in">abs</span>(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(max&lt;<span class="built_in">abs</span>(nums[i]))</span><br><span class="line">                max=<span class="built_in">abs</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> w=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(max&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            max/=<span class="number">10</span>;</span><br><span class="line">            w++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> flag=<span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;w;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bucket</span><span class="params">(<span class="number">19</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> temp=nums[j]/flag%<span class="number">10</span>+<span class="number">9</span>;</span><br><span class="line">                bucket[temp]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;<span class="number">19</span>;j++)</span><br><span class="line">                bucket[j]+=bucket[j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=n<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> temp=nums[j]/flag%<span class="number">10</span>+<span class="number">9</span>;</span><br><span class="line">                ans[--bucket[temp]]=nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            nums.<span class="built_in">swap</span>(ans);</span><br><span class="line">            flag*=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;大多数时候我们可以选择直接调用库函数来对序列进行排序，这里主要总结三种常见的复杂度较低的排序。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://3rdlight.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序" scheme="http://3rdlight.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>单调栈</title>
    <link href="http://3rdlight.github.io/2022/04/07/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <id>http://3rdlight.github.io/2022/04/07/%E5%8D%95%E8%B0%83%E6%A0%88/</id>
    <published>2022-04-07T03:41:03.000Z</published>
    <updated>2022-04-13T01:45:29.888Z</updated>
    
    <content type="html"><![CDATA[<p>单调栈即满足单调性的栈结构。与单调队列相比，其只在一端进行进出。</p><span id="more"></span><h4 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h4><p>单调栈分为单调递增栈和单调递减栈。</p><p><strong>单调递增栈</strong>即栈内元素保持单调递增的栈，<strong>单调递减栈</strong>即栈内元素保持单调递减的栈。</p><hr><h4 id="操作规则："><a href="#操作规则：" class="headerlink" title="操作规则："></a>操作规则：</h4><p>以单调递增栈为例：</p><p>如果新的元素比栈顶元素大，就入栈。</p><p>如果新的元素较小，那就<strong>一直</strong>把栈内元素弹出来，<strong>直到</strong>栈顶比新元素小。</p><hr><h4 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h4><p>加入这样一个规则之后：</p><p>栈内的元素是<strong>递增</strong>的。</p><p>当元素出栈时，说明这个<strong>新元素</strong>是出栈元素<strong>向后</strong>找第一个比其小的元素。</p><p>当元素出栈后，说明新<strong>栈顶元素</strong>是出栈元素<strong>向前</strong>找第一个比其小的元素。</p><hr><h4 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h4><p>用 O(N) 复杂度的一重遍历找到每个元素前后<strong>最近</strong>的更小&#x2F;大元素位置。</p><hr><h4 id="伪代码："><a href="#伪代码：" class="headerlink" title="伪代码："></a>伪代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>() &gt; nums[i])&#123;</span><br><span class="line">st.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">stk.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LeetCode 739题 每日温度：</p><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指在第 i 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = temperatures.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>()&amp;&amp;temperatures[i] &gt; temperatures[stk.<span class="built_in">top</span>()])&#123;<span class="comment">//当前元素大于栈顶元素</span></span><br><span class="line">                <span class="type">int</span> cur = stk.<span class="built_in">top</span>();  <span class="comment">//记录栈顶元素(索引)</span></span><br><span class="line">                res[cur] = i - cur;   <span class="comment">//当前索引减去栈顶索引就是对应的栈顶索引会有更高温度出现的天数</span></span><br><span class="line">                stk.<span class="built_in">pop</span>(); <span class="comment">//栈顶元素出栈</span></span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">push</span>(i); <span class="comment">//当前元素(索引)入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;单调栈即满足单调性的栈结构。与单调队列相比，其只在一端进行进出。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://3rdlight.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="栈" scheme="http://3rdlight.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="http://3rdlight.github.io/2022/04/04/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>http://3rdlight.github.io/2022/04/04/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
    <published>2022-04-04T02:54:59.000Z</published>
    <updated>2022-04-12T00:48:40.253Z</updated>
    
    <content type="html"><![CDATA[<p>最近陆陆续续做了一些题，越发能体会到：<strong>思路很简单，细节是魔鬼</strong>。</p><span id="more"></span><p>关于细节，主要就体现在<strong>mid</strong>到底是加一还是减一，<strong>while</strong>里面应该用 &lt;&#x3D; 还是 &lt; 。</p><hr><h4 id="一个笑话："><a href="#一个笑话：" class="headerlink" title="一个笑话："></a>一个笑话：</h4><p>有一天小明到图书馆借了 N 本书，出图书馆的时候，警报响了，于是保安把小明拦下，要检查一下哪本书没有登记出借。小明正准备把每一本书在报警器下过一下，以找出引发警报的书，但是保安露出不屑的眼神：你连二分查找都不会吗？于是保安把书分成两堆，让第一堆过一下报警器，报警器响；于是再把这堆书分成两堆…… 最终，检测了 <strong>logN</strong> 次之后，保安成功的找到了那本引起警报的书，露出了得意和嘲讽的笑容。于是小明背着剩下的书走了。</p><p>从此，图书馆丢了 N - 1 本书。</p><hr><h4 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h4><p>二分查找（binary search），也称折半搜索、对数搜索，是用来在一个<strong>有序</strong>数组中查找某一元素的算法。</p><p>以在一个升序数组中查找一个数为例。</p><p>它每次考察数组当前部分的中间元素，如果中间元素刚好是要找的，就结束搜索过程；如果中间元素小于所查找的值，那么左侧的只会更小，不会有所查找的元素，只需到右侧查找；如果中间元素大于所查找的值同理，只需到左侧查找。</p><hr><h4 id="时间复杂度：O-logN"><a href="#时间复杂度：O-logN" class="headerlink" title="时间复杂度：O(logN)"></a>时间复杂度：O(logN)</h4><hr><h4 id="常见的应用场景："><a href="#常见的应用场景：" class="headerlink" title="常见的应用场景："></a>常见的应用场景：</h4><p>查找一个数、查找左侧边界、查找右侧边界。</p><hr><h4 id="二分查找基本框架："><a href="#二分查找基本框架：" class="headerlink" title="二分查找基本框架："></a>二分查找基本框架：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = ...;</span><br><span class="line">    <span class="keyword">while</span>(...)&#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) &gt;&gt; <span class="number">1</span>; <span class="comment">//同理(left + right) / 2 </span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;<span class="comment">//可以防止数据太大直接相加导致数据溢出</span></span><br><span class="line">            ...;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;        <span class="comment">// ...标记的地方就是要注意细节的地方</span></span><br><span class="line">            left = ...;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            right =...;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最基本的二分查找："><a href="#最基本的二分查找：" class="headerlink" title="最基本的二分查找："></a>最基本的二分查找：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">初始化 right = nums.<span class="built_in">size</span>() - <span class="number">1</span> </span><br><span class="line"><span class="keyword">while</span>(left &lt;= right) <span class="comment">//终止条件为left == right + 1，此时区间[right+1, right]为空。</span></span><br><span class="line">    left = mid+<span class="number">1</span>，right = mid<span class="number">-1</span>; <span class="comment">// target == nums[mid]直接返回</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(left &lt; right) <span class="comment">//终止条件为left == right，此时区间[left, left]非空，还有一个被漏掉的数据需要处理。</span></span><br><span class="line">    nums[left] == target ? left : <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><h4 id="寻找左侧边界："><a href="#寻找左侧边界：" class="headerlink" title="寻找左侧边界："></a>寻找左侧边界：</h4><p>对于寻找左右边界的二分查找，常见的手法是使用<strong>左闭右开</strong>的搜索区间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">初始化 right = nums.length</span><br><span class="line"><span class="keyword">while</span> (left &lt; right) <span class="comment">//搜索区间是 [left, right)</span></span><br><span class="line">left = mid + <span class="number">1</span> 和 right = mid  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为我们需找到 target 的最左侧索引</span></span><br><span class="line"><span class="comment">//所以当 nums[mid] == target 时不要立即返回</span></span><br><span class="line"><span class="comment">//而要收紧右侧边界以锁定左侧边界</span></span><br></pre></td></tr></table></figure><h4 id="寻找右侧边界："><a href="#寻找右侧边界：" class="headerlink" title="寻找右侧边界："></a>寻找右侧边界：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">初始化 right = nums.length</span><br><span class="line"> <span class="keyword">while</span> (left &lt; right) <span class="comment">//搜索区间是 [left, right)</span></span><br><span class="line"> left = mid 和 right = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//因为我们需找到 target 的最右侧索引</span></span><br><span class="line"><span class="comment">//所以当 nums[mid] == target 时不要立即返回</span></span><br><span class="line"><span class="comment">//而要收紧左侧边界以锁定右侧边界</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近陆陆续续做了一些题，越发能体会到：&lt;strong&gt;思路很简单，细节是魔鬼&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://3rdlight.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="二分查找" scheme="http://3rdlight.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口</title>
    <link href="http://3rdlight.github.io/2022/04/01/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AC%94%E8%AE%B0/"/>
    <id>http://3rdlight.github.io/2022/04/01/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AC%94%E8%AE%B0/</id>
    <published>2022-04-01T04:18:10.000Z</published>
    <updated>2022-04-01T12:56:06.831Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h4><p>滑动窗口，顾名思义，就是使用双指针技巧，去维护一个窗口，不断滑动窗口（一端固定，另一端滑动），更新结果，找到最优解。麻烦的不是思路，主要是处理细节问题。</p><span id="more"></span><hr><h4 id="适用范围："><a href="#适用范围：" class="headerlink" title="适用范围："></a>适用范围：</h4><p>多用于解决子序列类的问题。</p><hr><h4 id="时间复杂度：O-N"><a href="#时间复杂度：O-N" class="headerlink" title="时间复杂度：O(N)"></a>时间复杂度：O(N)</h4><hr><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>1.初始化left &#x3D; right &#x3D; 0，个人习惯区间左闭右开[left,right)，方便处理，这样只要right右移一位，区间[0,1)就包含一个元素了。</p><p>2.先不断增加右指针right扩大窗口，直到窗口符合要求。</p><p>3.停止增加right，开始不断增加left缩小窗口，直到窗口不再符合要求。同时，每次增加left更新一次结果。</p><p>4.重复第2和第3步，直到right到达尽头。</p><p>思路就是第2步寻找可行解，第3步对可行解进行优化，最终找到最优解。</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化左右指针</span></span><br><span class="line"><span class="type">int</span> letf = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(right &lt; str.<span class="built_in">size</span>())&#123;</span><br><span class="line"><span class="comment">//c是将要移入窗口的字符</span></span><br><span class="line"><span class="type">char</span> c = str[right];</span><br><span class="line"><span class="comment">//增大窗口</span></span><br><span class="line">right++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//更新散列表或数组中数据</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span>(<span class="comment">/*左侧窗口需要收缩*/</span>)&#123;</span><br><span class="line"><span class="comment">//h是将要移出窗口的字符</span></span><br><span class="line"><span class="type">char</span> h = str[left];</span><br><span class="line"><span class="comment">//缩小窗口</span></span><br><span class="line">left++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//更新散列表或数组中数据</span></span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;简介：&quot;&gt;&lt;a href=&quot;#简介：&quot; class=&quot;headerlink&quot; title=&quot;简介：&quot;&gt;&lt;/a&gt;简介：&lt;/h4&gt;&lt;p&gt;滑动窗口，顾名思义，就是使用双指针技巧，去维护一个窗口，不断滑动窗口（一端固定，另一端滑动），更新结果，找到最优解。麻烦的不是思路，主要是处理细节问题。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://3rdlight.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="滑动窗口" scheme="http://3rdlight.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>回溯算法</title>
    <link href="http://3rdlight.github.io/2022/03/25/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/"/>
    <id>http://3rdlight.github.io/2022/03/25/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/</id>
    <published>2022-03-25T02:06:17.000Z</published>
    <updated>2022-04-01T12:55:54.290Z</updated>
    
    <content type="html"><![CDATA[<p>关于回溯，比较难的是理解 “回到过去”，<strong>现实世界里我们无法回到过去，但是在算法的世界里可以</strong>。</p><hr><span id="more"></span><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>深度优先遍历、递归、栈它们三者之间的关系：</p><p>它们背后统一的逻辑都是<strong>后进先出</strong>。</p><hr><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>回溯法 采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，<strong>它将取消上一步甚至是上几步的计算</strong>，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：</p><p>找到一个可能存在的正确的答案；<br>在尝试了所有可能的分步方法后宣告该问题没有答案。</p><p>（来自维基百科）</p><hr><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>回溯算法就是暴力穷举，解决回溯问题，典型的是利用决策树的结构，使用深度优先搜索（DFS）进行遍历，用一个不断变化的变量，试探各种可能的分步，寻找需要的结果，当发现有的分步不能得到有效解答的时候，只有取消上一次的计算，状态重置，回到之前的状态，<strong>这样再开始新的尝试才会是有效的</strong>。</p><p>回溯算法框架：</p><p>1.结束条件</p><p>2.选择路径</p><p>3.状态重置</p><hr><h3 id="剪枝："><a href="#剪枝：" class="headerlink" title="剪枝："></a>剪枝：</h3><p>回溯算法可以用剪枝来进行优化，寻找过滤条件，减少不必要的过程，以加快搜索速度。</p><p>剪枝的预处理工作（例如排序）虽然会消耗时间，但剪枝节约的时间更多。</p><p>由于回溯穷举的特点，其本身时间复杂度就很高，所以可以尽可能的使用空间换取时间。</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于回溯，比较难的是理解 “回到过去”，&lt;strong&gt;现实世界里我们无法回到过去，但是在算法的世界里可以&lt;/strong&gt;。&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="算法" scheme="http://3rdlight.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="回溯" scheme="http://3rdlight.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>写在前面</title>
    <link href="http://3rdlight.github.io/2022/03/19/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/"/>
    <id>http://3rdlight.github.io/2022/03/19/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/</id>
    <published>2022-03-19T07:22:00.000Z</published>
    <updated>2022-10-15T09:22:44.674Z</updated>
    
    <content type="html"><![CDATA[<p>写在前面的话，其实是最难写的。</p><p>让我这样一本正经的写开篇的文章，着实难受。</p><span id="more"></span><p>被隔离了。</p><p>在情况不明朗的时候，人总是会迫切的想做点什么。</p><p>那就做个博客吧。</p><p>从有这个念头到完成这个博客，花了大概两天时间。</p><p>此博客使用Hexo和GitHub pages搭建，项目部署在GitHub。我不会前端的东西，暂时也抽不出时间来仔细学，就只能先做成这样了。</p><p>建立此博客的初衷仅仅是记录一些技术上的东西，偶尔发一些生活日常。</p><p>隔离的日子，非常简单，我很难真正记住每一天，只要静下心来做一些事情，其实过得也挺快的。</p><p>最后，但愿我能做到将此博客持续更新。</p><p>道阻且长，行则将至。</p><hr><p>于重庆Steigenberger酒店</p><img src="/2022/03/19/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/%E5%A4%96%E6%99%AF.JPG" class>]]></content>
    
    
    <summary type="html">&lt;p&gt;写在前面的话，其实是最难写的。&lt;/p&gt;
&lt;p&gt;让我这样一本正经的写开篇的文章，着实难受。&lt;/p&gt;</summary>
    
    
    
    <category term="生活" scheme="http://3rdlight.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="http://3rdlight.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
</feed>
