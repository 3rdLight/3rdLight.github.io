<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小朱&#39;Blog</title>
  
  <subtitle>个人技术博客</subtitle>
  <link href="http://3rdlight.github.io/atom.xml" rel="self"/>
  
  <link href="http://3rdlight.github.io/"/>
  <updated>2022-03-23T03:39:11.509Z</updated>
  <id>http://3rdlight.github.io/</id>
  
  <author>
    <name>Zhu Bingguang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>回溯算法笔记</title>
    <link href="http://3rdlight.github.io/2022/03/23/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/"/>
    <id>http://3rdlight.github.io/2022/03/23/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/</id>
    <published>2022-03-23T02:12:17.000Z</published>
    <updated>2022-03-23T03:39:11.509Z</updated>
    
    <content type="html"><![CDATA[<p>关于回溯，比较难的是理解 “回到过去”，<strong>现实世界里我们无法回到过去，但是在算法的世界里可以</strong>。</p><hr><span id="more"></span><p>思考深度优先遍历、递归、栈它们三者之间的关系：</p><p>它们背后统一的逻辑都是<strong>后进先出</strong>。</p><hr><p><strong>回溯法</strong> 采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：</p><p>找到一个可能存在的正确的答案；<br>在尝试了所有可能的分步方法后宣告该问题没有答案。</p><hr><p>回溯算法有“不撞南墙不回头”的意思。当发现有的分步不能得到有效解答的时候，只有取消上一次的计算，状态重置，回到过去，<strong>这样再开始新的尝试才会是有效的</strong>。</p><hr><p><strong>剪枝</strong>：</p><p>回溯算法可以用剪枝来进行优化，寻找过滤条件，减少不必要的过程，以加快搜索速度。</p><p>剪枝的预处理工作（例如排序）虽然会消耗时间，但剪枝节约的时间更多。</p><p>由于回溯遍历的特点，其本身时间复杂度就很高，所以可以尽可能的使用空间换取时间。</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于回溯，比较难的是理解 “回到过去”，&lt;strong&gt;现实世界里我们无法回到过去，但是在算法的世界里可以&lt;/strong&gt;。&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="算法" scheme="http://3rdlight.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="回溯" scheme="http://3rdlight.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>c++ vector容器</title>
    <link href="http://3rdlight.github.io/2022/03/20/cpp-vector%E5%AE%B9%E5%99%A8/"/>
    <id>http://3rdlight.github.io/2022/03/20/cpp-vector%E5%AE%B9%E5%99%A8/</id>
    <published>2022-03-20T15:40:46.000Z</published>
    <updated>2022-03-23T02:20:04.702Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是vector："><a href="#什么是vector：" class="headerlink" title="什么是vector："></a>什么是vector：</h3><p>Vector是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，Vector是一个能够存放任意类型的动态数组。</p><span id="more"></span><hr><h3 id="容器特性："><a href="#容器特性：" class="headerlink" title="容器特性："></a>容器特性：</h3><h4 id="顺序序列"><a href="#顺序序列" class="headerlink" title="顺序序列"></a>顺序序列</h4><p>顺序容器中的元素按照严格的线性顺序排序。可以通过元素在序列中的位置访问对应的元素。</p><h4 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h4><p>支持对序列中的任意元素进行快速直接访问，甚至可以通过指针算述进行该操作。提供了在序列末尾相对快速地添加&#x2F;删除元素的操作。</p><h4 id="能够感知内存分配器的（Allocator-aware）"><a href="#能够感知内存分配器的（Allocator-aware）" class="headerlink" title="能够感知内存分配器的（Allocator-aware）"></a>能够感知内存分配器的（Allocator-aware）</h4><p>容器使用一个内存分配器对象来动态地处理它的存储需求。</p><hr><h3 id="基本函数实现："><a href="#基本函数实现：" class="headerlink" title="基本函数实现："></a>基本函数实现：</h3><p>vector():创建一个空vector</p><p>vector(int nSize):创建一个vector,元素个数为nSize</p><p>vector(int nSize,const t&amp; t):创建一个vector，元素个数为nSize,且值均为t</p><p>vector(const vector&amp;):复制构造函数</p><p>vector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中</p><hr><h3 id="基本用法："><a href="#基本用法：" class="headerlink" title="基本用法："></a>基本用法：</h3><p>Vector&lt;类型&gt;标识符</p><p>Vector&lt;类型&gt;标识符(最大容量)</p><p>Vector&lt;类型&gt;标识符(最大容量,初始所有值)</p><p>Int i[5]&#x3D;{1,2,3,4,5}<br>Vector&lt;类型&gt;vi(I,i+2);&#x2F;&#x2F;得到i索引值为3以后的值</p><p>Vector&lt; vector&lt; int&gt; &gt;v; 二维向量&#x2F;&#x2F;<strong>注意这里最外的&lt;&gt;要有空格。否则在比较旧的编译器下无法通过</strong></p><hr>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;什么是vector：&quot;&gt;&lt;a href=&quot;#什么是vector：&quot; class=&quot;headerlink&quot; title=&quot;什么是vector：&quot;&gt;&lt;/a&gt;什么是vector：&lt;/h3&gt;&lt;p&gt;Vector是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，Vector是一个能够存放任意类型的动态数组。&lt;/p&gt;</summary>
    
    
    
    <category term="c++" scheme="http://3rdlight.github.io/categories/c/"/>
    
    
    <category term="c++" scheme="http://3rdlight.github.io/tags/c/"/>
    
    <category term="vector" scheme="http://3rdlight.github.io/tags/vector/"/>
    
    <category term="STL" scheme="http://3rdlight.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>写在前面</title>
    <link href="http://3rdlight.github.io/2022/03/19/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/"/>
    <id>http://3rdlight.github.io/2022/03/19/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/</id>
    <published>2022-03-19T07:22:00.000Z</published>
    <updated>2022-03-23T02:09:30.987Z</updated>
    
    <content type="html"><![CDATA[<p>写在前面的话，其实是最难写的。</p><p>让我这样一本正经的写开篇的文章，着实难受。</p><span id="more"></span><p>被隔离了。</p><p>3月13办理入住，告知3月16解除，16当天又通知我要继续隔离到3月27，万幸酒店环境设施还不错。</p><p>在情况不明朗的时候，人总是会迫切的想做点什么。</p><p>那就做个Blog吧。</p><p>从有这个念头到完成这个Blog，花了大概两天时间，期间问了一些朋友，自己也查了一些资料。</p><p>此Blog使用Hexo和GitHub pages搭建，项目部署在GitHub。我不会前端的东西，暂时也抽不出时间来仔细学，就只能先做成这样了。</p><p>建立此Blog的初衷仅仅是记录一些技术上的东西，偶尔发发自己的生活日常。</p><p>隔离的日子，非常简单，我很难真正记住每一天，只要静下心来学习，做一些事情，其实过得也挺快的，并没有多难熬。</p><p>最后，但愿我能做到将此博客持续更新。</p><p>道阻且长，行则将至。</p><hr><p>于重庆Steigenberger酒店</p><img src="/2022/03/19/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/123.jpg" class title="This is an example image"><img src="/2022/03/19/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/IMG_2785.JPG" class title="This is an example image">]]></content>
    
    
    <summary type="html">&lt;p&gt;写在前面的话，其实是最难写的。&lt;/p&gt;
&lt;p&gt;让我这样一本正经的写开篇的文章，着实难受。&lt;/p&gt;</summary>
    
    
    
    <category term="生活" scheme="http://3rdlight.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="写在前面" scheme="http://3rdlight.github.io/tags/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/"/>
    
  </entry>
  
</feed>
