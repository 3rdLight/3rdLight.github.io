<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mute</title>
  
  <subtitle>个人技术博客</subtitle>
  <link href="http://3rdlight.github.io/atom.xml" rel="self"/>
  
  <link href="http://3rdlight.github.io/"/>
  <updated>2022-04-12T20:51:13.668Z</updated>
  <id>http://3rdlight.github.io/</id>
  
  <author>
    <name>小朱</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>你想失去什么</title>
    <link href="http://3rdlight.github.io/2022/04/08/%E4%BD%A0%E6%83%B3%E5%A4%B1%E5%8E%BB%E4%BB%80%E4%B9%88/"/>
    <id>http://3rdlight.github.io/2022/04/08/%E4%BD%A0%E6%83%B3%E5%A4%B1%E5%8E%BB%E4%BB%80%E4%B9%88/</id>
    <published>2022-04-07T19:35:26.000Z</published>
    <updated>2022-04-12T20:51:13.668Z</updated>
    
    <content type="html"><![CDATA[<p>你想失去什么</p><span id="more"></span><p>很有意思的问题。</p><hr><p>最近看了一篇有关苯教的文章，里面提到了这个反人性的问题。</p><p>你失去的东西，或许不是事物本身消失了，而是在你的认知里被屏蔽了。</p><hr><p>一个记录片，讲的是一位母亲始终不相信自己有一个女儿，她终日焦虑，觉得房间里还有另一个人，各种东西会突然消失，放在她面前的一个苹果，她女儿过来碰了苹果一下，苹果在她的感知里就消失了。虽然她女儿就在她身边，但是她从来看不见她，连同和她女儿有关的一切，她都无法看到。</p><p>后面揭晓，因为她自己的原因，让女儿出了事故，因为巨大的内疚，她的大脑把有关女儿的一切信息都屏蔽了。</p><p>京极夏彦的《姑获鸟之夏》里面也有类似的内容。</p><hr><p>往往是真正重要的事物更容易失去，因为太在乎。</p><p>一旦丢失了他们，你的人生会有一块空缺，那种空虚感会不断提醒你：</p><p>你失去了自己的一部分。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;你想失去什么&lt;/p&gt;</summary>
    
    
    
    <category term="日志" scheme="http://3rdlight.github.io/categories/%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="journal" scheme="http://3rdlight.github.io/tags/journal/"/>
    
  </entry>
  
  <entry>
    <title>单调栈</title>
    <link href="http://3rdlight.github.io/2022/04/07/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <id>http://3rdlight.github.io/2022/04/07/%E5%8D%95%E8%B0%83%E6%A0%88/</id>
    <published>2022-04-07T03:41:03.000Z</published>
    <updated>2022-04-13T01:45:29.888Z</updated>
    
    <content type="html"><![CDATA[<p>单调栈即满足单调性的栈结构。与单调队列相比，其只在一端进行进出。</p><span id="more"></span><h4 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h4><p>单调栈分为单调递增栈和单调递减栈。</p><p><strong>单调递增栈</strong>即栈内元素保持单调递增的栈，<strong>单调递减栈</strong>即栈内元素保持单调递减的栈。</p><hr><h4 id="操作规则："><a href="#操作规则：" class="headerlink" title="操作规则："></a>操作规则：</h4><p>以单调递增栈为例：</p><p>如果新的元素比栈顶元素大，就入栈。</p><p>如果新的元素较小，那就<strong>一直</strong>把栈内元素弹出来，<strong>直到</strong>栈顶比新元素小。</p><hr><h4 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h4><p>加入这样一个规则之后：</p><p>栈内的元素是<strong>递增</strong>的。</p><p>当元素出栈时，说明这个<strong>新元素</strong>是出栈元素<strong>向后</strong>找第一个比其小的元素。</p><p>当元素出栈后，说明新<strong>栈顶元素</strong>是出栈元素<strong>向前</strong>找第一个比其小的元素。</p><hr><h4 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h4><p>用 O(N) 复杂度的一重遍历找到每个元素前后<strong>最近</strong>的更小&#x2F;大元素位置。</p><hr><h4 id="伪代码："><a href="#伪代码：" class="headerlink" title="伪代码："></a>伪代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>() &gt; nums[i])&#123;</span><br><span class="line">st.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">stk.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LeetCode 739题 每日温度：</p><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指在第 i 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = temperatures.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>()&amp;&amp;temperatures[i] &gt; temperatures[stk.<span class="built_in">top</span>()])&#123;<span class="comment">//当前元素大于栈顶元素</span></span><br><span class="line">                <span class="type">int</span> cur = stk.<span class="built_in">top</span>();  <span class="comment">//记录栈顶元素(索引)</span></span><br><span class="line">                res[cur] = i - cur;   <span class="comment">//当前索引减去栈顶索引就是对应的栈顶索引会有更高温度出现的天数</span></span><br><span class="line">                stk.<span class="built_in">pop</span>(); <span class="comment">//栈顶元素出栈</span></span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">push</span>(i); <span class="comment">//当前元素(索引)入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;单调栈即满足单调性的栈结构。与单调队列相比，其只在一端进行进出。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://3rdlight.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="栈" scheme="http://3rdlight.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="http://3rdlight.github.io/2022/04/04/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>http://3rdlight.github.io/2022/04/04/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
    <published>2022-04-04T02:54:59.000Z</published>
    <updated>2022-04-12T00:48:40.253Z</updated>
    
    <content type="html"><![CDATA[<p>最近陆陆续续做了一些题，越发能体会到：<strong>思路很简单，细节是魔鬼</strong>。</p><span id="more"></span><p>关于细节，主要就体现在<strong>mid</strong>到底是加一还是减一，<strong>while</strong>里面应该用 &lt;&#x3D; 还是 &lt; 。</p><hr><h4 id="一个笑话："><a href="#一个笑话：" class="headerlink" title="一个笑话："></a>一个笑话：</h4><p>有一天小明到图书馆借了 N 本书，出图书馆的时候，警报响了，于是保安把小明拦下，要检查一下哪本书没有登记出借。小明正准备把每一本书在报警器下过一下，以找出引发警报的书，但是保安露出不屑的眼神：你连二分查找都不会吗？于是保安把书分成两堆，让第一堆过一下报警器，报警器响；于是再把这堆书分成两堆…… 最终，检测了 <strong>logN</strong> 次之后，保安成功的找到了那本引起警报的书，露出了得意和嘲讽的笑容。于是小明背着剩下的书走了。</p><p>从此，图书馆丢了 N - 1 本书。</p><hr><h4 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h4><p>二分查找（binary search），也称折半搜索、对数搜索，是用来在一个<strong>有序</strong>数组中查找某一元素的算法。</p><p>以在一个升序数组中查找一个数为例。</p><p>它每次考察数组当前部分的中间元素，如果中间元素刚好是要找的，就结束搜索过程；如果中间元素小于所查找的值，那么左侧的只会更小，不会有所查找的元素，只需到右侧查找；如果中间元素大于所查找的值同理，只需到左侧查找。</p><hr><h4 id="时间复杂度：O-logN"><a href="#时间复杂度：O-logN" class="headerlink" title="时间复杂度：O(logN)"></a>时间复杂度：O(logN)</h4><hr><h4 id="常见的应用场景："><a href="#常见的应用场景：" class="headerlink" title="常见的应用场景："></a>常见的应用场景：</h4><p>查找一个数、查找左侧边界、查找右侧边界。</p><hr><h4 id="二分查找基本框架："><a href="#二分查找基本框架：" class="headerlink" title="二分查找基本框架："></a>二分查找基本框架：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = ...;</span><br><span class="line">    <span class="keyword">while</span>(...)&#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) &gt;&gt; <span class="number">1</span>; <span class="comment">//同理(left + right) / 2 </span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;<span class="comment">//可以防止数据太大直接相加导致数据溢出</span></span><br><span class="line">            ...;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;        <span class="comment">// ...标记的地方就是要注意细节的地方</span></span><br><span class="line">            left = ...;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            right =...;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最基本的二分查找："><a href="#最基本的二分查找：" class="headerlink" title="最基本的二分查找："></a>最基本的二分查找：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">初始化 right = nums.<span class="built_in">size</span>() - <span class="number">1</span> </span><br><span class="line"><span class="keyword">while</span>(left &lt;= right) <span class="comment">//终止条件为left == right + 1，此时区间[right+1, right]为空。</span></span><br><span class="line">    left = mid+<span class="number">1</span>，right = mid<span class="number">-1</span>; <span class="comment">// target == nums[mid]直接返回</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(left &lt; right) <span class="comment">//终止条件为left == right，此时区间[left, left]非空，还有一个被漏掉的数据需要处理。</span></span><br><span class="line">    nums[left] == target ? left : <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><h4 id="寻找左侧边界："><a href="#寻找左侧边界：" class="headerlink" title="寻找左侧边界："></a>寻找左侧边界：</h4><p>对于寻找左右边界的二分查找，常见的手法是使用<strong>左闭右开</strong>的搜索区间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">初始化 right = nums.length</span><br><span class="line"><span class="keyword">while</span> (left &lt; right) <span class="comment">//搜索区间是 [left, right)</span></span><br><span class="line">left = mid + <span class="number">1</span> 和 right = mid  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为我们需找到 target 的最左侧索引</span></span><br><span class="line"><span class="comment">//所以当 nums[mid] == target 时不要立即返回</span></span><br><span class="line"><span class="comment">//而要收紧右侧边界以锁定左侧边界</span></span><br></pre></td></tr></table></figure><h4 id="寻找右侧边界："><a href="#寻找右侧边界：" class="headerlink" title="寻找右侧边界："></a>寻找右侧边界：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">初始化 right = nums.length</span><br><span class="line"> <span class="keyword">while</span> (left &lt; right) <span class="comment">//搜索区间是 [left, right)</span></span><br><span class="line"> left = mid 和 right = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//因为我们需找到 target 的最右侧索引</span></span><br><span class="line"><span class="comment">//所以当 nums[mid] == target 时不要立即返回</span></span><br><span class="line"><span class="comment">//而要收紧左侧边界以锁定右侧边界</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近陆陆续续做了一些题，越发能体会到：&lt;strong&gt;思路很简单，细节是魔鬼&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://3rdlight.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="二分查找" scheme="http://3rdlight.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口</title>
    <link href="http://3rdlight.github.io/2022/04/01/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AC%94%E8%AE%B0/"/>
    <id>http://3rdlight.github.io/2022/04/01/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AC%94%E8%AE%B0/</id>
    <published>2022-04-01T04:18:10.000Z</published>
    <updated>2022-04-01T12:56:06.831Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h4><p>滑动窗口，顾名思义，就是使用双指针技巧，去维护一个窗口，不断滑动窗口（一端固定，另一端滑动），更新结果，找到最优解。麻烦的不是思路，主要是处理细节问题。</p><span id="more"></span><hr><h4 id="适用范围："><a href="#适用范围：" class="headerlink" title="适用范围："></a>适用范围：</h4><p>多用于解决子序列类的问题。</p><hr><h4 id="时间复杂度：O-N"><a href="#时间复杂度：O-N" class="headerlink" title="时间复杂度：O(N)"></a>时间复杂度：O(N)</h4><hr><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>1.初始化left &#x3D; right &#x3D; 0，个人习惯区间左闭右开[left,right)，方便处理，这样只要right右移一位，区间[0,1)就包含一个元素了。</p><p>2.先不断增加右指针right扩大窗口，直到窗口符合要求。</p><p>3.停止增加right，开始不断增加left缩小窗口，直到窗口不再符合要求。同时，每次增加left更新一次结果。</p><p>4.重复第2和第3步，直到right到达尽头。</p><p>思路就是第2步寻找可行解，第3步对可行解进行优化，最终找到最优解。</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化左右指针</span></span><br><span class="line"><span class="type">int</span> letf = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(right &lt; str.<span class="built_in">size</span>())&#123;</span><br><span class="line"><span class="comment">//c是将要移入窗口的字符</span></span><br><span class="line"><span class="type">char</span> c = str[right];</span><br><span class="line"><span class="comment">//增大窗口</span></span><br><span class="line">right++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//更新散列表或数组中数据</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span>(<span class="comment">/*左侧窗口需要收缩*/</span>)&#123;</span><br><span class="line"><span class="comment">//h是将要移出窗口的字符</span></span><br><span class="line"><span class="type">char</span> h = str[left];</span><br><span class="line"><span class="comment">//缩小窗口</span></span><br><span class="line">left++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//更新散列表或数组中数据</span></span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;简介：&quot;&gt;&lt;a href=&quot;#简介：&quot; class=&quot;headerlink&quot; title=&quot;简介：&quot;&gt;&lt;/a&gt;简介：&lt;/h4&gt;&lt;p&gt;滑动窗口，顾名思义，就是使用双指针技巧，去维护一个窗口，不断滑动窗口（一端固定，另一端滑动），更新结果，找到最优解。麻烦的不是思路，主要是处理细节问题。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://3rdlight.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="滑动窗口" scheme="http://3rdlight.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>回溯算法</title>
    <link href="http://3rdlight.github.io/2022/03/25/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/"/>
    <id>http://3rdlight.github.io/2022/03/25/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/</id>
    <published>2022-03-25T02:06:17.000Z</published>
    <updated>2022-04-01T12:55:54.290Z</updated>
    
    <content type="html"><![CDATA[<p>关于回溯，比较难的是理解 “回到过去”，<strong>现实世界里我们无法回到过去，但是在算法的世界里可以</strong>。</p><hr><span id="more"></span><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>深度优先遍历、递归、栈它们三者之间的关系：</p><p>它们背后统一的逻辑都是<strong>后进先出</strong>。</p><hr><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>回溯法 采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，<strong>它将取消上一步甚至是上几步的计算</strong>，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：</p><p>找到一个可能存在的正确的答案；<br>在尝试了所有可能的分步方法后宣告该问题没有答案。</p><p>（来自维基百科）</p><hr><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>回溯算法就是暴力穷举，解决回溯问题，典型的是利用决策树的结构，使用深度优先搜索（DFS）进行遍历，用一个不断变化的变量，试探各种可能的分步，寻找需要的结果，当发现有的分步不能得到有效解答的时候，只有取消上一次的计算，状态重置，回到之前的状态，<strong>这样再开始新的尝试才会是有效的</strong>。</p><p>回溯算法框架：</p><p>1.结束条件</p><p>2.选择路径</p><p>3.状态重置</p><hr><h3 id="剪枝："><a href="#剪枝：" class="headerlink" title="剪枝："></a>剪枝：</h3><p>回溯算法可以用剪枝来进行优化，寻找过滤条件，减少不必要的过程，以加快搜索速度。</p><p>剪枝的预处理工作（例如排序）虽然会消耗时间，但剪枝节约的时间更多。</p><p>由于回溯穷举的特点，其本身时间复杂度就很高，所以可以尽可能的使用空间换取时间。</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于回溯，比较难的是理解 “回到过去”，&lt;strong&gt;现实世界里我们无法回到过去，但是在算法的世界里可以&lt;/strong&gt;。&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="算法" scheme="http://3rdlight.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="回溯" scheme="http://3rdlight.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>写在前面</title>
    <link href="http://3rdlight.github.io/2022/03/19/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/"/>
    <id>http://3rdlight.github.io/2022/03/19/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/</id>
    <published>2022-03-19T07:22:00.000Z</published>
    <updated>2022-04-12T01:38:26.058Z</updated>
    
    <content type="html"><![CDATA[<p>写在前面的话，其实是最难写的。</p><p>让我这样一本正经的写开篇的文章，着实难受。</p><span id="more"></span><p>被隔离了。</p><p>在情况不明朗的时候，人总是会迫切的想做点什么。</p><p>那就做个博客吧。</p><p>从有这个念头到完成这个博客，花了大概两天时间，期间问了一些朋友，自己也查了一些资料。</p><p>此博客使用Hexo和GitHub pages搭建，项目部署在GitHub。我不会前端的东西，暂时也抽不出时间来仔细学，就只能先做成这样了。</p><p>建立此博客的初衷仅仅是记录一些技术上的东西，偶尔发发自己的生活日常。</p><p>隔离的日子，非常简单，我很难真正记住每一天，只要静下心来学习，做一些事情，其实过得也挺快的，并没有多难熬。</p><p>最后，但愿我能做到将此博客持续更新。</p><p>道阻且长，行则将至。</p><hr><p>于重庆Steigenberger酒店</p><img src="/2022/03/19/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/123.jpg" class><img src="/2022/03/19/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/IMG_2785.JPG" class>]]></content>
    
    
    <summary type="html">&lt;p&gt;写在前面的话，其实是最难写的。&lt;/p&gt;
&lt;p&gt;让我这样一本正经的写开篇的文章，着实难受。&lt;/p&gt;</summary>
    
    
    
    <category term="生活" scheme="http://3rdlight.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="写在前面" scheme="http://3rdlight.github.io/tags/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/"/>
    
  </entry>
  
</feed>
