<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mute</title>
  
  <subtitle>个人技术博客</subtitle>
  <link href="http://3rdlight.github.io/atom.xml" rel="self"/>
  
  <link href="http://3rdlight.github.io/"/>
  <updated>2022-04-01T12:56:06.831Z</updated>
  <id>http://3rdlight.github.io/</id>
  
  <author>
    <name>小朱</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>滑动窗口</title>
    <link href="http://3rdlight.github.io/2022/04/01/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AC%94%E8%AE%B0/"/>
    <id>http://3rdlight.github.io/2022/04/01/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AC%94%E8%AE%B0/</id>
    <published>2022-04-01T04:18:10.000Z</published>
    <updated>2022-04-01T12:56:06.831Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h4><p>滑动窗口，顾名思义，就是使用双指针技巧，去维护一个窗口，不断滑动窗口（一端固定，另一端滑动），更新结果，找到最优解。麻烦的不是思路，主要是处理细节问题。</p><span id="more"></span><hr><h4 id="适用范围："><a href="#适用范围：" class="headerlink" title="适用范围："></a>适用范围：</h4><p>多用于解决子序列类的问题。</p><hr><h4 id="时间复杂度：O-N"><a href="#时间复杂度：O-N" class="headerlink" title="时间复杂度：O(N)"></a>时间复杂度：O(N)</h4><hr><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>1.初始化left &#x3D; right &#x3D; 0，个人习惯区间左闭右开[left,right)，方便处理，这样只要right右移一位，区间[0,1)就包含一个元素了。</p><p>2.先不断增加右指针right扩大窗口，直到窗口符合要求。</p><p>3.停止增加right，开始不断增加left缩小窗口，直到窗口不再符合要求。同时，每次增加left更新一次结果。</p><p>4.重复第2和第3步，直到right到达尽头。</p><p>思路就是第2步寻找可行解，第3步对可行解进行优化，最终找到最优解。</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化左右指针</span></span><br><span class="line"><span class="type">int</span> letf = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(right &lt; str.<span class="built_in">size</span>())&#123;</span><br><span class="line"><span class="comment">//c是将要移入窗口的字符</span></span><br><span class="line"><span class="type">char</span> c = str[right];</span><br><span class="line"><span class="comment">//增大窗口</span></span><br><span class="line">right++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//更新散列表或数组中数据</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span>(<span class="comment">/*左侧窗口需要收缩*/</span>)&#123;</span><br><span class="line"><span class="comment">//h是将要移出窗口的字符</span></span><br><span class="line"><span class="type">char</span> h = str[left];</span><br><span class="line"><span class="comment">//缩小窗口</span></span><br><span class="line">left++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//更新散列表或数组中数据</span></span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;简介：&quot;&gt;&lt;a href=&quot;#简介：&quot; class=&quot;headerlink&quot; title=&quot;简介：&quot;&gt;&lt;/a&gt;简介：&lt;/h4&gt;&lt;p&gt;滑动窗口，顾名思义，就是使用双指针技巧，去维护一个窗口，不断滑动窗口（一端固定，另一端滑动），更新结果，找到最优解。麻烦的不是思路，主要是处理细节问题。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://3rdlight.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="滑动窗口" scheme="http://3rdlight.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>回溯算法</title>
    <link href="http://3rdlight.github.io/2022/03/25/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/"/>
    <id>http://3rdlight.github.io/2022/03/25/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/</id>
    <published>2022-03-25T02:06:17.000Z</published>
    <updated>2022-04-01T12:55:54.290Z</updated>
    
    <content type="html"><![CDATA[<p>关于回溯，比较难的是理解 “回到过去”，<strong>现实世界里我们无法回到过去，但是在算法的世界里可以</strong>。</p><hr><span id="more"></span><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>深度优先遍历、递归、栈它们三者之间的关系：</p><p>它们背后统一的逻辑都是<strong>后进先出</strong>。</p><hr><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>回溯法 采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，<strong>它将取消上一步甚至是上几步的计算</strong>，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：</p><p>找到一个可能存在的正确的答案；<br>在尝试了所有可能的分步方法后宣告该问题没有答案。</p><p>（来自维基百科）</p><hr><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>回溯算法就是暴力穷举，解决回溯问题，典型的是利用决策树的结构，使用深度优先搜索（DFS）进行遍历，用一个不断变化的变量，试探各种可能的分步，寻找需要的结果，当发现有的分步不能得到有效解答的时候，只有取消上一次的计算，状态重置，回到之前的状态，<strong>这样再开始新的尝试才会是有效的</strong>。</p><p>回溯算法框架：</p><p>1.结束条件</p><p>2.选择路径</p><p>3.状态重置</p><hr><h3 id="剪枝："><a href="#剪枝：" class="headerlink" title="剪枝："></a>剪枝：</h3><p>回溯算法可以用剪枝来进行优化，寻找过滤条件，减少不必要的过程，以加快搜索速度。</p><p>剪枝的预处理工作（例如排序）虽然会消耗时间，但剪枝节约的时间更多。</p><p>由于回溯穷举的特点，其本身时间复杂度就很高，所以可以尽可能的使用空间换取时间。</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于回溯，比较难的是理解 “回到过去”，&lt;strong&gt;现实世界里我们无法回到过去，但是在算法的世界里可以&lt;/strong&gt;。&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="算法" scheme="http://3rdlight.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="回溯" scheme="http://3rdlight.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>写在前面</title>
    <link href="http://3rdlight.github.io/2022/03/19/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/"/>
    <id>http://3rdlight.github.io/2022/03/19/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/</id>
    <published>2022-03-19T07:22:00.000Z</published>
    <updated>2022-03-23T02:09:30.987Z</updated>
    
    <content type="html"><![CDATA[<p>写在前面的话，其实是最难写的。</p><p>让我这样一本正经的写开篇的文章，着实难受。</p><span id="more"></span><p>被隔离了。</p><p>3月13办理入住，告知3月16解除，16当天又通知我要继续隔离到3月27，万幸酒店环境设施还不错。</p><p>在情况不明朗的时候，人总是会迫切的想做点什么。</p><p>那就做个Blog吧。</p><p>从有这个念头到完成这个Blog，花了大概两天时间，期间问了一些朋友，自己也查了一些资料。</p><p>此Blog使用Hexo和GitHub pages搭建，项目部署在GitHub。我不会前端的东西，暂时也抽不出时间来仔细学，就只能先做成这样了。</p><p>建立此Blog的初衷仅仅是记录一些技术上的东西，偶尔发发自己的生活日常。</p><p>隔离的日子，非常简单，我很难真正记住每一天，只要静下心来学习，做一些事情，其实过得也挺快的，并没有多难熬。</p><p>最后，但愿我能做到将此博客持续更新。</p><p>道阻且长，行则将至。</p><hr><p>于重庆Steigenberger酒店</p><img src="/2022/03/19/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/123.jpg" class title="This is an example image"><img src="/2022/03/19/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/IMG_2785.JPG" class title="This is an example image">]]></content>
    
    
    <summary type="html">&lt;p&gt;写在前面的话，其实是最难写的。&lt;/p&gt;
&lt;p&gt;让我这样一本正经的写开篇的文章，着实难受。&lt;/p&gt;</summary>
    
    
    
    <category term="生活" scheme="http://3rdlight.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="写在前面" scheme="http://3rdlight.github.io/tags/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/"/>
    
  </entry>
  
</feed>
